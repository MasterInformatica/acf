load utils.maude
load full-maude 

(omod OBJETOS is
    pr STRING .
    pr UTILS .
    pr NAT .

    vars Q Q' : Qid .
    vars O O' O'' O''' : Oid .
    vars S S' S'' : String .
    vars Ob Ob' : Object .
    vars T T' : Tabla .
    vars M M' : Msg .
    vars C C' : Configuration . 
    vars L L' : listaMsg .
    var CS : CjtoString .


*** Ejercicio 1
    class Proceso | datos : Configuration .
*** Ejercicio 2, 10 y 11
    class Nodo | IP : String , Estado : State , recibido : String, 
                 amigos : CjtoString .
    op n : Qid -> Oid [ctor] .


    ****************************************************************************
    *** OJO: HAY QUE CAMBIAR ESTO PORQUE NO SIEMPRE SE EMPIEZA CON AMIGOS VACIOS
    ****************************************************************************
    *** nodo ( ID , IP)
    op nodo : Qid String  -> Object .
    eq nodo( Q, S) = < n(Q) : Nodo | IP : S , Estado : inactivo, 
				     recibido : "" , amigos : {""} > .
    

    sort State .
    ops inactivo esperando activo : -> State [ctor] .

*** Ejercicio 3
    class Centro | tabla : Tabla .
    subclass Centro < Nodo .
    *** y Sort Tabla

*** Ejercicio 4
    class Extremo | centro : Oid .
    subclass Extremo < Nodo .
    op null : -> Oid [ctor] .
    
    op extremo : Qid -> Object . 
    eq extremo(Q) = < Q : Extremo | centro : null > .

*** Ejercicio 5
    class Canal | origen : Oid, destino : Oid, listaOrigen : listaMsg, 
                  listaDestino : listaMsg, estado : EstadoCanal .
    
    sort EstadoCanal .
    ops ok error : -> EstadoCanal [ctor] .
    
    sort listaMsg .
    subsort Msg < listaMsg .
    op lmv : -> listaMsg [ctor] .
    op _/_ : listaMsg listaMsg -> listaMsg [ctor assoc id: lmv ] .



*** Ejercicio 6
    *** info(Self, IP)
    msg info : Oid String -> Msg .
   
    rl [send-info] :
	< O : Extremo | Estado : inactivo , IP : S, centro : null > 
      => 
	< O : Extremo | Estado : esperando > 
	info(O, S) .

*** Ejercicio 7
    *** respuesta-info(To, From)
    msg respuesta-info : Oid Oid -> Msg .

    *** receive info and send ack-info
    rl [ack-receive-info] : 
	info(n(O), S) 
	< n(O') : Centro | tabla : T > 
      => 
	< n(O') : Centro | tabla : insert({ S, O }, T) , Estado : activo > 
	respuesta-info( O, O') .


    rl [receive-ack-info] : 
	respuesta-info(O, O') 
	< n(O) : Extremo | centro : null, Estado : esperando > 
      => 
	< n(O) : Extremo | centro : O', Estado : activo > .

*** Ejercicio 12
    msg to_:_ : String String -> Msg .

*** Ejercicio 13
    msg to_:_ : Oid String -> Msg .

*** Ejercicio 14
 *** 14 a) insertar en el canal
    *** Solo insertamos si es un mensaje que no tenemos que procesar nosotros (de salida).
    
    rl [extremo-to-channel_info] : 
	< O : Proceso | datos : C info(n(O), S) >
	< O' : Canal | origen : O, listaDestino : L, estado : ok > 
      => 
	< O : Proceso | datos : C >
	< O' : Canal | origen : O, listaDestino : L / info(n(O), S),
		       estado : ok > .

    *** Sabemos que es un mensaje al centro porque es string-string
    rl [extremo-to-channel_to] :
	< O : Proceso | datos : C (to S : S') >
	< O' : Canal | origen : O, listaDestino : L, estado : ok >
      =>
	< O : Proceso | datos : C >
	< O' : Canal | origen : O, listaDestino : L / (to S : S'), 
		       estado : ok > .

    
    rl [centro-to-channel_respuesta-info] : 
     	< O : Proceso | datos : C respuesta-info( O', O ) >
     	< O'' : Canal | origen : O', destino : O, listaOrigen : L, 
		       estado : ok > 
      => 
     	< O : Proceso | datos : C >
     	< O'' : Canal | origen : O', destino : O, 
			listaOrigen : L / respuesta-info ( O', O ), 
			estado : ok >  .

    rl [centro-to-channel_to] :
	< O : Proceso | datos : C ( to O' : S ) >
	< O'' : Canal | origen : O', destino : O, listaOrigen : L,
			estado : ok >
      =>
	< O : Proceso | datos : C >
	< O'' : Canal | origen : O', destino : O, 
			listaOrigen : L / ( to O' : S ), estado : ok > .


    *** 14 b) extraer del canal.
    rl [channel-to-extremo] :
	< O : Proceso | datos : C >
	< O' : Canal | origen : O, listaOrigen : L / M, estado : ok >
      =>
	< O : Proceso | datos : C M >
	< O' : Canal | listaOrigen : L > .
    
    rl [channel-to-centro] :
	< O : Proceso | datos : C >
	< O' : Canal | destino : O, listaDestino : L / M, estado : ok >
      =>
	< O : Proceso | datos : C M >
	< O' : Canal | destino : O, listaDestino : L , estado : ok > .
    


*** Ejercicio 15
    ****************************************************************************
    *** OJO: Esto hay que descomentarlo. Si se deja descomentado se estropea ***
    *** el canal y no llega ningún mensaje				     ***
    ****************************************************************************
 ***(
    rl [estropea-canal] : 
    	< O : Canal | estado : ok >
      =>
    	< O : Canal | estado : error > .
  )    
  


*** Ejercicio 16
  ******************************************************************************
  *** Explicacion rapida: Para generar un mensaje para cada amigo, usamos	
  *** una funcion auxiliar que los genera todos a la vez (evitamos duplicados).	
  *** Pero esto no nos impide que volvamos a generarlos todos a la vez otra vez.
  *** De hecho, esto debería dar un bucle infinito.				
  *** vamos al lio a ver si es verdad:						
  ******************************************************************************

    op generaHellos : CjtoString -> Configuration .
    eq generaHellos( S ) = (to S : "hola" ) .
    eq generaHellos( S - CS ) = (to S : "hola") generaHellos( CS ) .


    *** OJO: borramos la lista de amigos para no enviar infinitos msgs.
    *** Chapuza para asegurarnos que los amigos no son vacios XD
    rl [saluda-amigos] :
	< O : Nodo | Estado : activo , amigos : S - CS > 
      =>
	< O : Nodo | Estado : activo , amigos : {""}  > 
	generaHellos ( S - CS ) .

    


*** Ejercicio 17
    rl [centro-convierte-msg] :
	( to S : S' )
	< O : Centro | Estado : activo , tabla : ( { S , O' } ) T >
      =>
	< O : Centro | Estado : activo , tabla : ( { S , O' } ) T >
	( to O' : S' ) .



*** Ejercicio 18

    rl [procesa-to-extremo] :
    	( to O : S )
    	< n(O) : Extremo | Estado : activo , recibido : S' >
      =>
    	< n(O) : Extremo | Estado : activo, recibido : S' + S > .


    rl [procesa-to-centro] :
	(to S : S')
	< O : Centro | Estado : activo , IP : S , recibido : S'' >
      =>
	< O : Centro | Estado : activo , IP : S , recibido : S'' + S' > .

*** Ejercicio 19
    op numObjetos : Configuration -> Nat .
    eq numObjetos( Ob C ) = 1 + numObjetos(C) .
    eq numObjetos( C ) = 0 [owise] .


*** Ejercicio 20
    op mismoNumObjetos : Configuration Configuration -> Bool .
    eq mismoNumObjetos( C, C' ) =
	numObjetos(C) == numObjetos(C') .
    ******************
    *** OJO: HACER ***
    ******************

***( search inicio =>* C:Configuration s.t. 
         numObjetos(inicio) =/= numObjetos(C) .)    

endom)

