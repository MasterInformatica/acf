load utils.maude
load full-maude 

(omod OBJETOS is
    pr STRING .
    pr UTILS .
    
    vars Q Q' : Qid .
    vars O O' O'' O''' : Oid .
    vars S S' : String .
    vars Ob Ob' : Object .
    vars T T' : Tabla .
    vars M M' : Msg .
    vars C C' : Configuration . 
    vars L L' : listaMsg .

*** Ejercicio 1
    class Proceso | datos : Configuration .
*** Ejercicio 2, 10 y 11
    class Nodo | IP : String , Estado : State , recibido : String, amigos : CjtoString .
    op n : Qid -> Oid [ctor] .
    *** nodo ( ID , IP)
    op nodo : Qid String  -> Object .
    eq nodo( Q, S) = < n(Q) : Nodo | IP : S , Estado : inactivo, recibido : "" , amigos : {""} > .
    

    sort State .
    ops inactivo esperando activo : -> State [ctor] .

*** Ejercicio 3
    class Centro | tabla : Tabla .
    subclass Centro < Nodo .
    *** y Sort Tabla

*** Ejercicio 4
    class Extremo | centro : Oid .
    subclass Extremo < Nodo .
    op null : -> Oid [ctor] .
    
    op extremo : Qid -> Object . 
    eq extremo(Q) = < Q : Extremo | centro : null > .

*** Ejercicio 5
    class Canal | origen : Oid, destino : Oid, listaOrigen : listaMsg, 
                  listaDestino : listaMsg, estado : EstadoCanal .
    
    sort EstadoCanal .
    ops ok error : -> EstadoCanal [ctor] .
    
    sort listaMsg .
    subsort Msg < listaMsg .
    op lmv : -> listaMsg [ctor] .
    op _/_ : listaMsg listaMsg -> listaMsg [ctor assoc id: lmv ] .



*** Ejercicio 6
    *** info(Self, IP)
    msg info : Oid String -> Msg .
   
    rl [send-info] : 
	< O : Extremo | Estado : inactivo , IP : S, centro : null > 
      => 
	< O : Extremo | Estado : esperando > 
	info(O, S) .

*** Ejercicio 7
    *** respuesta-info(To, From)
    msg respuesta-info : Oid Oid -> Msg .

    *** receive info and send ack-info
    rl [ack-info] : 
	info(O, S) 
	< O' : Centro | tabla : T > 
      => 
	< O' : Centro | tabla : insert({ S,O }, T) , Estado : activo > 
	respuesta-info( O, O') .


    rl [receive-ack-info] : 
	respuesta-info(O, O') 
	< O : Extremo | centro : null, Estado : esperando > 
      => 
	< O : Extremo | centro : O', Estado : activo > .

*** Ejercicio 12
    msg to_:_ : String String -> Msg .

*** Ejercicio 13
    msg to_:_ : Oid String -> Msg .

***     class Canal | origen : Oid, destino : Oid, listaOrigen : listaMsg, 
***                  listaDestino : listaMsg, estado : EstadoCanal .

*** Ejercicio 14
    *** extremo = origen
    *** centro = destino


 *** 14 a) insertar en el canal
    rl [extremo-to-channel] : 
	< O : Proceso | datos : C M >
	< O' : Canal | origen : O, listaDestino : L, estado : ok > 
      => 
	< O' : Canal | origen : O, listaDestino : L / M, estado : ok > .

     *** NO SE SI ESTE IF FUNCIONA. OJO
    crl [centro-to-channel] : 
	< O : Proceso | datos : C M >
	< O' : Canal | origen : getDestino(M), destino : O,
		       listaOrigen : L, estado : ok > 
      => 
	< O' : Canal | listaOrigen : L / M > 
      if getDestino(M) :: Oid .
    
 *** 14 b) extraer del canal
    *** rl [channel-to-extremo] :
    *** 	< O : Proceso | datos : C >
    *** 	< O' : Canal | origen : O, listaOrigen: L' / M , estado: ok >
    ***   =>
    *** 	< O : Proceso | datos : C M > 
    *** 	< O' : Canal | origen : O, listaOrigen: L', estado: ok > .









    *** Dado un mensaje cualquiera, devuelve el destino. Func, parcial
    op getDestino : Msg ~> Oid .
    eq getDestino(to O : S) = O .
    eq getDestino( respuesta-info( O , O' ) ) = O .



endom)

 ***(
*** TODO : get destino
   op getDest : Msg Canal ~> Oid .
    eq getDest( respuesta-info( O, O' ), < ) = O .
    eq getDest( info( O, S) ) = 


    rl [origen-to-channel] : 
	< O : Canal | origen : O', listaDestino : L , estado : ok >
	M < O
)***	




